plot(1:Rep, M, type = "l")
plot(1:Rep, xvec, type = "l")
sqrt(5000)
3*sqrt(2)+1
100*log(100) - 100
(1/18)*(1/4) + (1/7)*(3/4)
0.1210317*4*7*9
0.1210317*4*7*18
4*7*18
300/8 - 4000*5/8
-2462.5*2
5/8*(1+25+5)/3*10^6 +  3*2/8*100^2
2462.5*8
6465833*8
dpois(7, lambda = 5.5)
5.5^7/factorial(3)/factorial(4)*exp(-5.5)*5^4*4^3/9^7
sqrt(log(112)/112)
sqrt(2*log(112)/112)
sqrt(2*log(122)/122)
log(112)/112
2*log(122)/122
n = 122;
n/log(n)
(n/log(n))/27
log(n)/sqrt(n)
log(n)/sqrt(n)/27
2*log(n)/sqrt(n)/27
##### Read libraries / functions
#setwd("~/Project/Proj-Social Network/New")
library(igraph)
library(Matrix)
library(pracma)
library(aricode)
source("Various Functions.R")
source("Mtable.R")
### attribute matrix
load("CovariatesMatrix.Rdata")
getwd()
a = seq(0, 100, by = 0.001)
y1 = pnorm(-a);
plot(y1)
plot(a, y1, type = "l")
y2 = exp(-a^2)/a;
plot(y2-y1)
plot(a, y2-y1)
plot(a, y2-y1, type = "l")
min(y2-y1)
which.min(y2-y1)
a[1870]
a = seq(0, 3, by = 0.001)
y1 = pnorm(-a);
y2 = exp(-a^2)/a;
plot(a, y2-y1, type = "l")
a = seq(0.1, 3, by = 0.001)
y1 = pnorm(-a);
y2 = exp(-a^2)/a;
plot(a, y2-y1, type = "l")
a = seq(0.5, 3, by = 0.001)
y1 = pnorm(-a);
y2 = exp(-a^2)/a;
plot(a, y2-y1, type = "l")
min(y2-y1)
a = seq(1, 3, by = 0.001)
y1 = pnorm(-a);
y2 = exp(-a^2)/a;
plot(a, y2-y1, type = "l")
y1[which.min(y2-y1)]
y2[which.min(y2-y1)]
min(y2*2-y1)
which.min(y2*2-y1)
a[1194]
y2[which.min(y2*2-y1)]
y1[which.min(y2*2-y1)]
which(y2*2-y1 > 0)
a = seq(0.5, 3, by = 0.001)
y1 = pnorm(-a);
y2 = exp(-a^2/2)/a;
plot(a, y2-y1, type = "l")
min(y2-y1)
y2 = exp(-a^2)/a*sqrt(2*pi)
min(y2-y1)
1-1.2/sqrt(2)
1/( 1-1.2/sqrt(2))
game = rep(0, 100);
for(k in 1:100){
n = 100;
X = rbinom(n, 1, 1/2)
for(i in 1:n){
while(X[i] + X[i+1] == 2){
game[kk] = i+1;
}
break;
}
}
game = rep(0, 100);
for(k in 1:100){
n = 100;
X = rbinom(n, 1, 1/2)
for(i in 1:n){
while(X[i] + X[i+1] == 2){
game[k] = i+1;
}
break;
}
}
.2^2 - 0.19^2
.24*.29 - .26^2
##### Hastlings-Metropolis ##########
### Permutation Example ###
NoNeighbor <- function(x, a){
#The function is to check N(x) for any vector x
n = length(x);
value = sum((1:n)*x);
DiffValue = matrix(-Inf, nrow = n, ncol = n);
#the matrix is to record the difference of sum j*x[j] between x and its neighbor
for(i in 2:n){
vec = 1:(i - 1);
DiffValue[i, vec] = (vec - i)*(x[i] - x[vec]);
}
return(sum(value + DiffValue >= a))
}
NextJump <- function(x, a){
n = length(x); value = 0;
while(value < a){
U1 = runif(1); U2 = runif(1);
Ind1 = floor(n*U1) + 1; #unif{1, 2, 3, ..., n}
Ind2 = floor((n-1)*U2) + 1; #unif{1, 2, ..., n-1}
Ind2 = Ind2 + 1*(Ind2 >= Ind1); #adjust
y = x; y[Ind1] = x[Ind2]; y[Ind2] = x[Ind1];
value = sum((1:n)*y);
}
return(y)
}
## Run MCMC ###
n = 20;
a = 2600;
#Initialisation
M = 5000;
xn = rep(0, M); value = rep(0, M);
x = 1:n; #Initial state
for(m in 1:M){
#Consider a jump
y = NextJump(x, a);
U = runif(1);
Nx = NoNeighbor(x, a);
Ny = NoNeighbor(y, a);
if(U < min(Nx/Ny, 1)) x = y;
#Accept this jump only when U < min(Nx/Ny, 1); otherwise stay at x.
xn[m] = x[n];
value[m] = sum((1:n)*x);
}
#Truncation
xn = xn[1001:M];
hist(xn, breaks = 20)
mean(xn)
mean_change = xn*0;
for(j in 1:length(xn)){
mean_change[j] = mean(xn[1:j])
#  if(j > 500) mean_change[j] = mean(xn[(j-500):j])
}
plot(mean_change, type = "l")
#Generate Y from Q
NextJump <- function(x){
Nx = 2*max(x, 1)
y = rbinom(Nx, 1, 1/2);
return(y)
}
#Initialisation
M = 5000; # run 5000 steps
xn = rep(0, M); #the vector to save every step
x = 1;
for(m in 1:M){
#Consider a jump
x = 1;
y = NextJump(x);
#calculate alpha
Nx = 2*max(x, 1);
Ny = 2*max(y, 1);
alpha = min(5^(y-x)*factorial(Nx - y)/factorial(Ny - x)*factorial(Ny)/factorial(Nx)*2^(Nx-Ny), 1)
#decide whether the next jump will be accepted or not
U = runif(1);
if(U < alpha) x = y;
xn[m] = x;
}
warnings()
xn[m]
x
m
length(xn)
length(x)
#Generate Y from Q
NextJump <- function(x){
Nx = 2*max(x, 1)
y = rbinom(1, Nx, 1/2);
return(y)
}
#Initialisation
M = 5000; # run 5000 steps
xn = rep(0, M); #the vector to save every step
x = 1;
for(m in 1:M){
#Consider a jump
x = 1;
y = NextJump(x);
#calculate alpha
Nx = 2*max(x, 1);
Ny = 2*max(y, 1);
alpha = min(5^(y-x)*factorial(Nx - y)/factorial(Ny - x)*factorial(Ny)/factorial(Nx)*2^(Nx-Ny), 1)
#decide whether the next jump will be accepted or not
U = runif(1);
if(U < alpha) x = y;
xn[m] = x;
}
#the generated chain
plot(xn)
#the generated chain
plot(xn, type = "l")
#Truncation
xn = xn[1001:M];
hist(xn, breaks = 20)
#Initialisation
M = 5000; # run 5000 steps
xn = rep(0, M); #the vector to save every step
x = 1;
for(m in 1:M){
#Consider a jump
y = NextJump(x);
#calculate alpha
Nx = 2*max(x, 1);
Ny = 2*max(y, 1);
alpha = min(5^(y-x)*factorial(Nx - y)/factorial(Ny - x)*factorial(Ny)/factorial(Nx)*2^(Nx-Ny), 1)
#decide whether the next jump will be accepted or not
U = runif(1);
if(U < alpha) x = y;
xn[m] = x;
}
U
alpha
Nx
Ny
5^(y-x)*factorial(Nx - y)/factorial(Ny - x)*factorial(Ny)/factorial(Nx)*2^(Nx-Ny)
x
y
x = 1;
for(m in 1:M){
#Consider a jump
y = NextJump(x);
#calculate alpha
Nx = 2*max(x, 1);
Ny = 2*max(y, 1);
if(Ny < x) alpha = 0;
else{
for(m in 1:M){
#Consider a jump
y = NextJump(x);
#calculate alpha
Nx = 2*max(x, 1);
Ny = 2*max(y, 1);
if(Ny < x) {alpha = 0;}
else{
alpha = min(5^(y-x)*factorial(Nx - y)/factorial(Ny - x)*factorial(Ny)/factorial(Nx)*2^(Nx-Ny), 1);
}
#decide whether the next jump will be accepted or not
U = runif(1);
if(U < alpha) x = y;
xn[m] = x;
}
#the generated chain
plot(xn, type = "l")
#Truncation
xn = xn[1001:M];
hist(xn, breaks = 20)
#the generated chain
plot(xn, type = "l")
# The early stage of the process
hist(xn[1:500], breaks = 20)
# The early stage of the process
hist(xn[1:100], breaks = 20)
# The early stage of the process
plot(xn[1:100], type = "l")
hist(xn[1:100], breaks = 20)
# More steps of the process
plot(xn[1:1000], type = "l")
hist(xn[1:1000], breaks = 20)
#Truncation (to be safe, we cut many steps)
xn = xn[1001:M];
hist(xn, breaks = 20)
mean(xn)
xn
sum(is.na(xn))
M
length(xn)
which(is.na(xn))
xn[3001]
xn[3000:3010]
x = 1;
for(m in 1:M){
#Consider a jump
y = NextJump(x);
#calculate alpha
Nx = 2*max(x, 1);
Ny = 2*max(y, 1);
if(Ny < x) {alpha = 0;}
else{
alpha = min(5^(y-x)*factorial(Nx - y)/factorial(Ny - x)*factorial(Ny)/factorial(Nx)*2^(Nx-Ny), 1);
}
#decide whether the next jump will be accepted or not
U = runif(1);
if(U < alpha) x = y;
xn[m] = x;
}
#the generated chain
plot(xn, type = "l")
# The early stage of the process
plot(xn[1:100], type = "l")
hist(xn[1:100], breaks = 20)
# More steps of the process
plot(xn[1:1000], type = "l")
hist(xn[1:1000], breaks = 20)
sum(is.na(xn))
#Truncation (to be safe, we cut many steps)
hist(xn[1001:M], breaks = 20)
mean(xn[1001:M])
### Example 3: Permutation ###
NoNeighbor <- function(x, a){
#The function is to check N(x) for any vector x
n = length(x);
value = sum((1:n)*x);
DiffValue = matrix(-Inf, nrow = n, ncol = n);
#the matrix is to record the difference of sum j*x[j] between x and its neighbor
for(i in 2:n){
vec = 1:(i - 1);
DiffValue[i, vec] = (vec - i)*(x[i] - x[vec]);
}
return(sum(value + DiffValue >= a))
}
NextJump <- function(x, a){
n = length(x); value = 0;
while(value < a){
U1 = runif(1); U2 = runif(1);
Ind1 = floor(n*U1) + 1; #unif{1, 2, 3, ..., n}
Ind2 = floor((n-1)*U2) + 1; #unif{1, 2, ..., n-1}
Ind2 = Ind2 + 1*(Ind2 >= Ind1); #adjust
y = x; y[Ind1] = x[Ind2]; y[Ind2] = x[Ind1];
value = sum((1:n)*y);
}
return(y)
}
## Run MCMC: you can change n and a ###
n = 20;
a = 2600;
#Initialisation
M = 5000;
xn = rep(0, M); value = rep(0, M);
x = 1:n; #Initial state
for(m in 1:M){
#Consider a jump
y = NextJump(x, a);
U = runif(1);
Nx = NoNeighbor(x, a);
Ny = NoNeighbor(y, a);
if(U < min(Nx/Ny, 1)) x = y;
#Accept this jump only when U < min(Nx/Ny, 1); otherwise stay at x.
xn[m] = x[n];
value[m] = sum((1:n)*x);
}
#Truncation
xn = xn[1001:M];
hist(xn, breaks = 20)
mean(xn)
mean_change = xn*0;
for(j in 1:length(xn)){
mean_change[j] = mean(xn[1:j])
#  if(j > 500) mean_change[j] = mean(xn[(j-500):j])
}
plot(mean_change, type = "l")
##### Hastlings-Metropolis: Continuous Case ##########
Alpha <- function(x, y, c){
# This function is to check alpha(X, Y)
return(min(exp((x^2 - y^2))/2*pgamma(c-y, 2, 3)/
pgamma(c-x, 2, 3)*pnorm((c-x)/sigma)/pnorm((c-y)/sigma), 1))
}
NextJump <- function(x, c){
repeat{
U = runif(1); R = runif(1);
Y = sigma*sqrt(-2*log(R))*cos(2*pi*U)+x;
if(Y < c) return(Y)
}
}
## Run MCMC ###
c = 3;
sigma = 0.1;
#Initialisation
M = 10000;
allx = rep(0, M);
x = 0; #Initial state
for(m in 1:M){
V = runif(1);
y = NextJump(x, c);
if(V < Alpha(x, y, c)) x = y;
allx[m] = x;
}
plot(allx, type = "l")
#Truncation
allx = allx[2001:M];
hist(allx, breaks = 20)
mean(allx)
#Remarks
# You have to check the jumps, to avoid the case that the chain always stays
# at 1 state
# You have to check how many points in the truncation is sufficient
mean_change = allx*0;
for(j in 1:length(allx)){
mean_change[j] = mean(allx[1:j])
}
plot(mean_change, type = "l")
# Generate normal random variables
polar <- function(U1, U2){
X = sqrt(-2*log(U1))*cos(2*pi*U2);
}
24*6
exp(2) - 1
y = seq(1, 10, by = 0.01)
min(y - log(y) + 1)
z = y*exp(-4*sqrt(y) - 1)
plot(z)
plot(z, type = "l")
z[y == 16]
min(z)
##### Read libraries / functions
#setwd("~/Project/Proj-Social Network/New")
library(igraph)
library(Matrix)
library(pracma)
library(aricode)
source("Various Functions.R")
X = as.matrix(sparseX)
n = dim(X)[1]; p = dim(X)[2]
### adjacency matrix
edgelist = read.csv("lastfm_asia_edges.csv")
setwd("~/Dropbox/Yaofang-Wanjie/Code/LastFM")
##### Read libraries / functions
#setwd("~/Project/Proj-Social Network/New")
library(igraph)
library(Matrix)
library(pracma)
library(aricode)
source("Various Functions.R")
source("Mtable.R")
### attribute matrix
load("CovariatesMatrix.Rdata")
X = as.matrix(sparseX)
n = dim(X)[1]; p = dim(X)[2]
### adjacency matrix
edgelist = read.csv("lastfm_asia_edges.csv")
edgelist = edgelist + 1
A = matrix(0, n, n)
for (i in 1: dim(edgelist)[1]){
A[edgelist[i, 1], edgelist[i, 2]] = 1
}
A = A + t(A)
### country label
label = read.csv('lastfm_asia_target.csv')
label = label$target
label = label + 1
unique(label)
table(label)
## delete country with 17 users only
ind5 = which(label != 5);
A = A[ind5, ind5]; X = X[ind5,]; label = label[ind5];
X = X[, colSums(X) > 0];
labelnew = label;
label[labelnew > 5] = label[labelnew > 5] - 1;
rm(labelnew);
n = dim(A)[1]; p = dim(X)[2]
dartist_all = colSums(X);
## We only consider the comparable countries
sizes = summary(as.factor(label))
# Curret Degrees
d = rowSums(A);
k = length(unique(label))
dave = rep(0, k)
for(i in 1:length(unique(label))){
dave[i] = mean(d[label == i])
}
class_select = names(sizes)[sizes < 100 & sizes > 50]
A1 = Aselect; X1 = Xselect;
###Select the corresponding nodes
ind.select = which(label %in% as.vector(class_select))
Aselect = A[ind.select, ind.select]; Xselect = X[ind.select,];
labelselect = label[ind.select];
n = dim(Aselect)[1]; p = dim(Xselect)[2]
kk = length(unique(labelselect))
# Select the regional popular artists##
dartist = colSums(Xselect);
prop = dartist/dartist_all;
prob = 1 - round(min(n/2, 600)/p, 4);
Xselect = Xselect[, prop > quantile(prop, probs = prob, na.rm = TRUE)]
## Remove the users who like no artists
dnode = rowSums(Xselect)
like = which(dnode > 0)
Xselect = Xselect[like, ]
Aselect = Aselect[like, like]
labelselect = labelselect[like]
dselect = rowSums(Aselect)
n = dim(Aselect)[1]; p = dim(Xselect)[2]
A1 = Aselect; X1 = Xselect;
kk = length(unique(label))
kk = length(unique(labelselect))
kk
d = rowSums(A1);
est_nac = NAC(A1, X1, kk, alpha = mean(d)/2, beta = 0, startn = 50)
